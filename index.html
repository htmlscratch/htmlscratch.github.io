<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Blueprint Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --grid-color: #2a2a2a;
            --node-bg: #2d2d2d;
            --node-header: #3d3d3d;
            --text-color: #e0e0e0;
            --accent-color: #4a90e2;
            --html-accent: #e44d26;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            font-family: 'Inter', system-ui, sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            margin: 0;
        }

        /* Split Screen Layout */
        #workspace {
            flex: 1;
            position: relative;
            border-right: 2px solid #444;
            overflow: hidden;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 25px 25px;
        }

        #output-window {
            width: 40%;
            background: #fff;
            display: flex;
            flex-direction: column;
        }

        #preview-header {
            background: #f0f0f0;
            color: #333;
            padding: 10px;
            font-weight: bold;
            font-size: 0.8rem;
            border-bottom: 1px solid #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #preview-frame {
            flex: 1;
            border: none;
            background: white;
        }

        /* Node Styling */
        .node {
            position: absolute;
            width: 220px;
            background: var(--node-bg);
            border: 1px solid #444;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            user-select: none;
            z-index: 10;
            transition: box-shadow 0.2s;
        }

        .node:hover {
            box-shadow: 0 0 10px var(--accent-color);
        }

        .node-header {
            padding: 10px;
            background: var(--node-header);
            border-bottom: 1px solid #444;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .node-content { padding: 12px; }

        .port-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 0.75rem;
            position: relative;
        }

        .port {
            width: 14px;
            height: 14px;
            background: #666;
            border: 2px solid #222;
            border-radius: 4px;
            cursor: crosshair;
            z-index: 20;
        }

        .port:hover { background: var(--accent-color); }
        .port.input { margin-left: -20px; }
        .port.output { margin-right: -20px; background: var(--html-accent); }

        svg#connections {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .connection-line {
            fill: none;
            stroke: var(--html-accent);
            stroke-width: 3;
            stroke-linecap: round;
        }

        .toolbar {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 100;
            background: rgba(30, 30, 30, 0.9);
            padding: 10px;
            border-radius: 12px;
            border: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 300px;
        }

        .btn {
            background: #444;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: white;
            transition: all 0.2s;
        }

        .btn:hover { 
            background: var(--accent-color);
            transform: translateY(-1px);
        }

        input, textarea, select {
            background: #111;
            color: #fff;
            border: 1px solid #555;
            width: 100%;
            font-size: 0.75rem;
            padding: 6px;
            border-radius: 4px;
            margin-top: 4px;
            outline: none;
        }

        input:focus, textarea:focus {
            border-color: var(--accent-color);
        }
    </style>
</head>
<body>

    <div id="workspace">
        <div class="toolbar">
            <div class="w-full font-bold text-orange-500 mb-2 flex items-center text-sm border-b border-gray-700 pb-1">
                HTML5 Builder Node Editor
            </div>
            <button class="btn" onclick="addNode('Page')">Page Root</button>
            <button class="btn" onclick="addNode('Header')">Header</button>
            <button class="btn" onclick="addNode('Text')">Paragraph</button>
            <button class="btn" onclick="addNode('Button')">Button</button>
            <button class="btn" onclick="addNode('Image')">Image</button>
        </div>
        <svg id="connections"></svg>
    </div>

    <div id="output-window">
        <div id="preview-header">
            <span>Website Preview</span>
            <div class="flex gap-2">
                <button onclick="updatePreview()" class="text-[10px] bg-blue-500 text-white px-2 py-1 rounded">Refresh</button>
            </div>
        </div>
        <iframe id="preview-frame"></iframe>
    </div>

    <script>
        const workspace = document.getElementById('workspace');
        const svg = document.getElementById('connections');
        const preview = document.getElementById('preview-frame');
        
        let nodes = [];
        let connections = [];
        let isDragging = false;
        let activeNode = null;
        let dragOffset = { x: 0, y: 0 };
        let pendingConnection = null;

        function addNode(type, x = 100, y = 100) {
            const id = 'node_' + Date.now();
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            nodeEl.id = id;
            nodeEl.style.left = x + 'px';
            nodeEl.style.top = y + 'px';

            let content = '';
            if (type === 'Page') {
                content = `
                    <div class="port-row"><div class="port input" data-port-id="${id}_content"></div><span>Body Content</span></div>
                    <div class="mt-2">
                        <label class="text-[10px] text-gray-400">Website Title</label>
                        <input type="text" value="My Project" oninput="updatePreview()" id="${id}_title">
                    </div>
                `;
            } else if (type === 'Header') {
                content = `
                    <div class="port-row"><span>Heading Link</span><div class="port output" data-port-id="${id}_out"></div></div>
                    <input type="text" value="Welcome to My Site" oninput="updatePreview()" id="${id}_text">
                    <select id="${id}_size" onchange="updatePreview()">
                        <option value="h1">H1 (Large)</option>
                        <option value="h2">H2 (Medium)</option>
                        <option value="h3">H3 (Small)</option>
                    </select>
                `;
            } else if (type === 'Text') {
                content = `
                    <div class="port-row"><span>Text Link</span><div class="port output" data-port-id="${id}_out"></div></div>
                    <textarea oninput="updatePreview()" id="${id}_text" rows="2">This is a paragraph built with nodes!</textarea>
                `;
            } else if (type === 'Button') {
                content = `
                    <div class="port-row"><span>Button Link</span><div class="port output" data-port-id="${id}_out"></div></div>
                    <input type="text" value="Learn More" oninput="updatePreview()" id="${id}_label">
                `;
            } else if (type === 'Image') {
                content = `
                    <div class="port-row"><span>Image Link</span><div class="port output" data-port-id="${id}_out"></div></div>
                    <input type="text" value="https://picsum.photos/400/200" oninput="updatePreview()" id="${id}_url">
                `;
            }

            nodeEl.innerHTML = `
                <div class="node-header">
                    <span>${type}</span>
                    <span class="cursor-pointer text-red-500 hover:text-white font-bold px-2" onclick="deleteNode('${id}')">‚úï</span>
                </div>
                <div class="node-content">${content}</div>
            `;

            workspace.appendChild(nodeEl);
            const nodeObj = { id, type, x, y, el: nodeEl };
            nodes.push(nodeObj);

            // Drag behavior
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.closest('.port') || e.target.closest('input') || e.target.closest('textarea') || e.target.closest('select')) return;
                isDragging = true;
                activeNode = nodeObj;
                dragOffset.x = e.clientX - nodeEl.offsetLeft;
                dragOffset.y = e.clientY - nodeEl.offsetTop;
                nodeEl.style.zIndex = 1000;
                // Move other nodes back
                nodes.forEach(n => { if(n.id !== id) n.el.style.zIndex = 10; });
            });

            // Port behavior
            nodeEl.querySelectorAll('.port').forEach(port => {
                port.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    const rect = port.getBoundingClientRect();
                    const workspaceRect = workspace.getBoundingClientRect();
                    pendingConnection = {
                        fromPort: port.dataset.portId,
                        fromNode: id,
                        isOutput: port.classList.contains('output'),
                        startX: rect.left + rect.width / 2 - workspaceRect.left,
                        startY: rect.top + rect.height / 2 - workspaceRect.top
                    };
                });
            });
            updatePreview();
        }

        function deleteNode(id) {
            nodes = nodes.filter(n => n.id !== id);
            connections = connections.filter(c => c.fromNode !== id && c.toNode !== id);
            const el = document.getElementById(id);
            if (el) el.remove();
            drawConnections();
            updatePreview();
        }

        window.addEventListener('mousemove', (e) => {
            const workspaceRect = workspace.getBoundingClientRect();
            if (isDragging && activeNode) {
                activeNode.x = e.clientX - dragOffset.x;
                activeNode.y = e.clientY - dragOffset.y;
                activeNode.el.style.left = activeNode.x + 'px';
                activeNode.el.style.top = activeNode.y + 'px';
                drawConnections();
            }
            if (pendingConnection) {
                drawConnections();
                const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
                line.setAttribute("class", "connection-line opacity-50");
                const currentX = e.clientX - workspaceRect.left;
                const currentY = e.clientY - workspaceRect.top;
                const d = calculateCurve(pendingConnection.startX, pendingConnection.startY, currentX, currentY);
                line.setAttribute("d", d);
                svg.appendChild(line);
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (pendingConnection) {
                const target = document.elementFromPoint(e.clientX, e.clientY);
                if (target && target.classList.contains('port')) {
                    const toPort = target.dataset.portId;
                    const toNode = toPort.split('_').slice(0, 2).join('_');
                    if (pendingConnection.isOutput !== target.classList.contains('output')) {
                        const outNode = pendingConnection.isOutput ? pendingConnection.fromNode : toNode;
                        const outPort = pendingConnection.isOutput ? pendingConnection.fromPort : toPort;
                        const inNode = pendingConnection.isOutput ? toNode : pendingConnection.fromNode;
                        const inPort = pendingConnection.isOutput ? toPort : pendingConnection.fromPort;
                        
                        // Prevent connecting node to itself
                        if (outNode !== inNode) {
                            // Ensure one connection per input
                            connections = connections.filter(c => c.toPort !== inPort);
                            connections.push({ fromNode: outNode, fromPort: outPort, toNode: inNode, toPort: inPort });
                        }
                    }
                }
            }
            isDragging = false; 
            activeNode = null; 
            pendingConnection = null;
            drawConnections();
            updatePreview();
        });

        function calculateCurve(x1, y1, x2, y2) {
            const dist = Math.abs(x2 - x1) * 0.5;
            return `M ${x1} ${y1} C ${x1 + dist} ${y1} ${x2 - dist} ${y2} ${x2} ${y2}`;
        }

        function drawConnections() {
            svg.innerHTML = '';
            const workspaceRect = workspace.getBoundingClientRect();
            connections.forEach(conn => {
                const p1El = document.querySelector(`[data-port-id="${conn.fromPort}"]`);
                const p2El = document.querySelector(`[data-port-id="${conn.toPort}"]`);
                if (p1El && p2El) {
                    const r1 = p1El.getBoundingClientRect();
                    const r2 = p2El.getBoundingClientRect();
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("class", "connection-line");
                    path.setAttribute("d", calculateCurve(
                        r1.left + 7 - workspaceRect.left, r1.top + 7 - workspaceRect.top, 
                        r2.left + 7 - workspaceRect.left, r2.top + 7 - workspaceRect.top
                    ));
                    svg.appendChild(path);
                }
            });
        }

        function updatePreview() {
            const rootNode = nodes.find(n => n.type === 'Page');
            if (!rootNode) {
                preview.srcdoc = `
                    <body style="background:#f8f8f8; display:flex; flex-direction:column; justify-content:center; align-items:center; height:100vh; font-family:sans-serif; color:#666;">
                        <div style="font-size:40px;">üèóÔ∏è</div>
                        <p>Add a <b>Page Root</b> node to start building.</p>
                    </body>`;
                return;
            }

            const pageTitle = document.getElementById(rootNode.id + '_title').value;
            
            function buildHTML(nodeId) {
                const node = nodes.find(n => n.id === nodeId);
                if (!node) return '';

                if (node.type === 'Header') {
                    const tag = document.getElementById(nodeId + '_size').value;
                    const text = document.getElementById(nodeId + '_text').value;
                    return `<${tag}>${text}</${tag}>`;
                } else if (node.type === 'Text') {
                    const text = document.getElementById(nodeId + '_text').value;
                    return `<p>${text.replace(/\n/g, '<br>')}</p>`;
                } else if (node.type === 'Button') {
                    const label = document.getElementById(nodeId + '_label').value;
                    return `<button style="background:#4a90e2; color:white; border:none; padding:12px 24px; border-radius:8px; font-weight:bold; cursor:pointer; display:block; margin:10px 0;">${label}</button>`;
                } else if (node.type === 'Image') {
                    const url = document.getElementById(nodeId + '_url').value;
                    return `<img src="${url}" style="width:100%; border-radius:12px; margin:15px 0; box-shadow:0 4px 10px rgba(0,0,0,0.1);" onerror="this.src='https://via.placeholder.com/400x200?text=Image+Not+Found'">`;
                }
                return '';
            }

            const connectedContent = connections
                .filter(c => c.toPort === rootNode.id + '_content')
                .map(c => buildHTML(c.fromNode))
                .join('');

            preview.srcdoc = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${pageTitle}</title>
                    <style>
                        body { 
                            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
                            padding: 40px; 
                            max-width: 800px;
                            margin: 0 auto;
                            color: #333; 
                            line-height: 1.6; 
                        }
                        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }
                        h2 { font-size: 1.8rem; border-bottom: 2px solid #eee; padding-bottom: 5px; }
                        p { font-size: 1.1rem; color: #555; }
                    </style>
                </head>
                <body>
                    ${connectedContent || '<div style="text-align:center; margin-top:50px;"><h1 style="color:#ddd">Empty Page</h1><p>Connect element nodes to the Page Root.</p></div>'}
                </body>
                </html>
            `;
        }

        // Auto-init
        window.onload = () => {
            addNode('Page', 500, 150);
            addNode('Header', 100, 50);
            addNode('Text', 100, 300);
            
            // Create a default connection after a small delay to ensure DOM is ready
            setTimeout(() => {
                if (nodes.length >= 2) {
                    connections.push({
                        fromNode: nodes[1].id,
                        fromPort: nodes[1].id + '_out',
                        toNode: nodes[0].id,
                        toPort: nodes[0].id + '_content'
                    });
                    drawConnections();
                    updatePreview();
                }
            }, 100);
        };
    </script>
</body>
</html>
